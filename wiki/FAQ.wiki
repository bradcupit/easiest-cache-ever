#summary questions I just made up

  # [#Which_license_is_this_released_under? Which license is this released under?]
  # [#Why_does_this_require_Spring_or_AspectJ? Why does this require Spring or AspectJ?]
  # [#What_is_an_AspectJ_load-time_weaver? What is an AspectJ load-time weaver?]
  # [#Why_isn't_caching_working? Why isn't caching working?]

===Which license is this released under?===
The Apache License 2.0, which basically says you can use this library or it's source code in any project (even commercial ones). You accept the code as-is, and can't sue me if something goes wrong. If you distribute the code or compiled files, or the jar (whether you modified it or not), you must include a copy of the license. If you just distribute the jar, it already includes the license in the jar, so you don't have to do anything.

The icon (which I found [http://www.iconspedia.com/icon/money-4135.html here]) is available under the LGPL.

For more information, see this [http://www.apache.org/foundation/licence-FAQ.html#WhatDoesItMEAN page].

===Why does this require Spring or AspectJ?===
easiest-cache-ever uses AOP (Aspect Oriented Programming), so you have to do very little work to enable caching. A plain annotation on a method doesn't really do much on it's own. The smarts are in the code which processes the annotation, and how will that smart code have access to your method which need caching? The answer is AOP, and the simplest way to setup AOP is through Spring. If you want to get fancy, you can use AspectJ (a new language based off Java that makes Aspects a first class citizen). The middle ground is an AspectJ load-time-weaver.

===What is an AspectJ load-time weaver?===
TODO

===Why isn't caching working?===

Is Spring/AspectJ caching setup properly? See the migration guide for help.
If using Spring AOP, are you calling a non-public method? Only public methods are supported with Spring AOP. You may want to try load-time-weaving, or make your method public.
With Spring AOP, are you calling a method within your own class? Spring AOP can only intercept calls from one object to another. It can't intercept calls from one object to itself, or from one object to it's super/subclasses. You may want to try load-time-weaving, or refactor your code so it's two separate objects.